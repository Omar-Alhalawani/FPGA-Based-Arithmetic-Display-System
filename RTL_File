// ============================================================================
// top.v  —  ZedBoard (Zynq-7000 XC7Z020) simple "FPGA display system"
//
// Purpose:
//   Demonstrate a small "FPGA-based arithmetic display system" using only:
//     - 8 DIP switches (SW0..SW7) as an input bus
//     - 5 push buttons (BTNx) as control signals
//     - 8 LEDs (LD0..LD7) as a binary display output
//
// User interaction:
//   1) Set SW[7:0] to desired value, press BTNL to load A
//   2) Set SW[7:0] to desired value, press BTNR to load B
//   3) Press BTNU to select ADD, or BTND to select SUB
//   4) Result appears on LEDs (LD7..LD0) as an 8-bit binary number
//   5) Press BTNC to reset A/B and mode
//
// Notes:
//   - Buttons are asynchronous to GCLK. We synchronize them with 2 flip-flops
//     (standard metastability protection).
//   - We also do a rising-edge detect so "one press = one action".
//   - This example does NOT implement full debouncing. If you see double-press
//     behavior due to mechanical bounce, we can add debounce next.
// ============================================================================

module top (
    // ------------------------------------------------------------------------
    // System clock input. On ZedBoard, the main FPGA clock is typically 100 MHz.
    // In your XDC, map the 100 MHz pin to this port name (GCLK).
    // ------------------------------------------------------------------------
    input  wire GCLK,

    // ------------------------------------------------------------------------
    // User DIP switches (8). Each is a 1-bit input. We'll combine them into a
    // single 8-bit bus internally so we can treat the switches as a number.
    // ------------------------------------------------------------------------
    input  wire SW0,
    input  wire SW1,
    input  wire SW2,
    input  wire SW3,
    input  wire SW4,
    input  wire SW5,
    input  wire SW6,
    input  wire SW7,

    // ------------------------------------------------------------------------
    // User push buttons (5). We'll use them as follows:
    //   BTNL: load A_reg from switches
    //   BTNR: load B_reg from switches
    //   BTNU: set mode to ADD
    //   BTND: set mode to SUB
    //   BTNC: reset (clear A/B, set mode to ADD)
    // ------------------------------------------------------------------------
    input  wire BTNC,
    input  wire BTND,
    input  wire BTNL,
    input  wire BTNR,
    input  wire BTNU,

    // ------------------------------------------------------------------------
    // User LEDs (8). We output the ALU result as an 8-bit binary display.
    // ------------------------------------------------------------------------
    output wire LD0,
    output wire LD1,
    output wire LD2,
    output wire LD3,
    output wire LD4,
    output wire LD5,
    output wire LD6,
    output wire LD7
);

    // =========================================================================
    // 1) Bundle individual switch inputs into one 8-bit bus
    // =========================================================================
    // sw[0] corresponds to SW0, sw[7] corresponds to SW7.
    // This is convenient for arithmetic and register storage.
    wire [7:0] sw;
    assign sw = {SW7, SW6, SW5, SW4, SW3, SW2, SW1, SW0};

    // =========================================================================
    // 2) Synchronize buttons (metastability protection)
    // =========================================================================
    // Mechanical buttons are asynchronous w.r.t. GCLK. Sampling an async signal
    // can violate setup/hold timing on a flip-flop, potentially causing
    // metastability (unpredictable intermediate voltage/time to settle).
    //
    // Standard fix: two flip-flops in series for each async signal.
    // After two stages, the probability of metastability affecting logic is
    // extremely low.
    reg [1:0] sync_c, sync_d, sync_l, sync_r, sync_u;

    always @(posedge GCLK) begin
        // Each line shifts the button signal through 2 FFs.
        sync_c <= {sync_c[0], BTNC};  // center button
        sync_d <= {sync_d[0], BTND};  // down button
        sync_l <= {sync_l[0], BTNL};  // left button
        sync_r <= {sync_r[0], BTNR};  // right button
        sync_u <= {sync_u[0], BTNU};  // up button
    end

    // The second stage (index [1]) is the stabilized synchronized signal.
    wire btn_c = sync_c[1];
    wire btn_d = sync_d[1];
    wire btn_l = sync_l[1];
    wire btn_r = sync_r[1];
    wire btn_u = sync_u[1];

    // =========================================================================
    // 3) Rising-edge detection ("one press = one action")
    // =========================================================================
    // If we used btn_l directly to load A, then holding BTNL for even 0.1s
    // would load A on every clock cycle during that time.
    //
    // To convert a "level" (held high) into a single pulse, we detect the
    // transition from 0 -> 1 (rising edge).
    //
    // Method: store previous button state and compare.
    reg btn_c_prev, btn_d_prev, btn_l_prev, btn_r_prev, btn_u_prev;

    always @(posedge GCLK) begin
        // Save current states so next cycle we can detect transitions.
        btn_c_prev <= btn_c;
        btn_d_prev <= btn_d;
        btn_l_prev <= btn_l;
        btn_r_prev <= btn_r;
        btn_u_prev <= btn_u;
    end

    // Rising edge occurs when current is 1 and previous was 0.
    wire c_rise =  btn_c & ~btn_c_prev;
    wire d_rise =  btn_d & ~btn_d_prev;
    wire l_rise =  btn_l & ~btn_l_prev;
    wire r_rise =  btn_r & ~btn_r_prev;
    wire u_rise =  btn_u & ~btn_u_prev;

    // =========================================================================
    // 4) Input registers for A and B
    // =========================================================================
    // We store A and B in registers so the value stays stable even when
    // switches change. This is exactly how you'd design a real interface:
    // capture user input on a control event (button press).
    reg [7:0] A_reg;
    reg [7:0] B_reg;

    // =========================================================================
    // 5) Mode register: selects ADD or SUB
    // =========================================================================
    // mode_sub = 0 -> ADD
    // mode_sub = 1 -> SUB
    reg mode_sub;

    // =========================================================================
    // 6) Sequential control logic: loads registers and updates mode
    // =========================================================================
    // Everything here happens on the clock edge, so it’s synchronous and stable.
    always @(posedge GCLK) begin
        // Reset/clear on center button rising edge
        if (c_rise) begin
            A_reg    <= 8'd0;   // clear A
            B_reg    <= 8'd0;   // clear B
            mode_sub <= 1'b0;   // default to ADD after reset
        end
        else begin
            // Load A when BTNL is pressed
            if (l_rise) begin
                A_reg <= sw;    // capture current switch value into A_reg
            end

            // Load B when BTNR is pressed
            if (r_rise) begin
                B_reg <= sw;    // capture current switch value into B_reg
            end

            // Set ADD mode when BTNU is pressed
            if (u_rise) begin
                mode_sub <= 1'b0;
            end

            // Set SUB mode when BTND is pressed
            if (d_rise) begin
                mode_sub <= 1'b1;
            end
        end
    end

    // =========================================================================
    // 7) Combinational ALU: computes result from A_reg and B_reg
    // =========================================================================
    // This block is combinational (always @*), meaning it updates immediately
    // when inputs change (A_reg, B_reg, mode_sub).
    //
    // We use 9 bits (alu_ext) so we can hold carry/borrow information if we want
    // later. For now, the board only has 8 LEDs, so we display [7:0].
    reg [8:0] alu_ext;

    always @(*) begin
        if (mode_sub) begin
            // Unsigned subtraction:
            // {1'b0, A_reg} makes A a 9-bit number with leading 0.
            // This prevents accidental sign-extension and keeps math unsigned.
            alu_ext = {1'b0, A_reg} - {1'b0, B_reg};
        end else begin
            // Unsigned addition:
            // The MSB alu_ext[8] will become 1 if there is a carry out.
            alu_ext = {1'b0, A_reg} + {1'b0, B_reg};
        end
    end

    // Extract the 8-bit result we will display.
    wire [7:0] result = alu_ext[7:0];

    // =========================================================================
    // 8) Drive LED outputs
    // =========================================================================
    // The concatenation on the left maps result bits to individual LEDs.
    // LD0 is LSB, LD7 is MSB (common convention).
    assign {LD7, LD6, LD5, LD4, LD3, LD2, LD1, LD0} = result;

endmodule
